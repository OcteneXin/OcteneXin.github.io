------



![image-20220513170332288](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220513170332288.png)

> 1.17之前，Minecraft所有的树。图像来源于Minecraft Wiki。



> *“你对树有什么了解？”*
>
> *“红黑树，霍夫曼树，最小生成树，平衡二叉搜索树，B树——”*
>
> *“好吧，我承认你数据结构学得还不错。”*

Minecraft中的树自然不是数据结构与算法中那些令人望而却步的树，但它们的本质逻辑是高度相似的。



### “树”在mc语境中的不同含义

| 语境                                         | 含义                                                         | 源码中对应的变量（或常量）                                   | 变量类型                                                     | 最终父类          |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------- |
| 我刚刚砍了一棵白桦树                         | 只是一些方块                                                 | /                                                            | /                                                            | /                 |
| 我捡到了几个白桦树，等会儿去种               | 树苗物品                                                     | Items类中的BIRCH_SAPLING                                     | ItemBlock                                                    | Item              |
| 我种下去的白桦树怎么还不长                   | 树苗方块                                                     | Blocks类中的BIRCH_SAPLING                                    | SaplingBlock                                                 | Block             |
| 这棵白桦树终于长了，还生成了蜂巢             | 树苗方块生长时获取树变种的管理器                             | SaplingBlock类中的treeGrower                                 | BirchTree                                                    | Tree              |
| mc的树木具有相似的构造，都有树干和树叶       | 尚未配置的特性                                               | Feature类中的TREE                                            | TreeFeature                                                  | Feature           |
| 有的白桦树悬挂着蜂巢，有的却没有             | 配置好的特性，描述单棵树的生成                               | Features类中的BIRCH和BIRCH_BEES_0002                         | ConfiguredFeature<BaseTreeFeatureConfig, ?>                  | ConfiguredFeature |
| 在白桦森林生物群系，白桦树不太紧密地成片生成 | 配置好的特性，描述树林的生成                                 | Features类中的TREES_BIRCH                                    | ConfiguredFeature<?, ?>                                      | ConfiguredFeature |
| mc有六种树，包括橡树、白桦树等               | 配置好的特性，描述单棵树的生成，具有原木和树叶的六种组合之一 | Features类中的OAK、FANCY_OAK、SWAMP_TREE、OAK_BADLANDS、OAK_BEES_0002都是橡树 | ConfiguredFeature<BaseTreeFeatureConfig, ?>或ConfiguredFeature<?, ?> | ConfiguredFeature |
| 紫颂树形状真奇特                             | 尚未配置的特性，但不是树                                     | Feature类中的CHORUS_PLANT                                    | Feature<NoFeatureConfig>                                     | Feature           |
| 紫颂树一般成片生成在末地大型外岛上           | 配置好的特性，但不是树                                       | Features类中的CHORUS_PLANT                                   | ConfiguredFeature<?, ?>                                      | ConfiguredFeature |

这里最后两行与我们讨论的树无关，写出来只是为了做一些区分。

理解这个表格有些困难，相对具体的部分靠上，越向下越难以理解，但只要看完这个系列的所有文章，这些就一下子全变得清晰了。



这里补充说明一下“特性”这回事。

#### Feature和Features

> *什么？这不是bug，这是特性！*
>
> ——据说来自Mojang某员工

我更愿意直接使用Feature这一英文本名，因为理解起来比较清晰。译名有这么几种：特性，地物，（小）结构。在这几种译名之中，我选择了”特性”，直译嘛，少些弯路。

Mojang对于Feature的处理有两个长得很像的类**Feature**，**Features**。

这种命名方式几乎贯穿mc始终，比如：Block和Blocks，Item和Items，它们的前者都是祖宗类（就像java里的Object类一样，Block类是所有方块的祖宗类），后者都是汇总类（里面全是register）。

当然，Feature是特殊的，它的祖宗类Feature还兼顾着汇总类的功能，里面注册了许多Feature，我更愿意称它为**初次汇总**。Features在初次汇总的基础上，经过某种Config的一顿操作，生产出更多变种，即注册了更多的ConfiguredFeature（数量达到初步汇总的4倍以上），我称之为**二次汇总**。ConfiguredFeature才能被数据包所识别，真正被加载到世界中。（如果二次汇总时不想再导出变种（比如紫颂树），我们使用IFeatureConfig.NONE。它什么也不做，唯一的用处是把**尚未配置的特性Feature**转化为**已配置的特性ConfiguredFeature**）

以下展示了Feature类和Features类的代码。一字之差，天差地别。

```java
//Feature.java

public abstract class Feature<FC extends IFeatureConfig> extends net.minecraftforge.registries.ForgeRegistryEntry<Feature<?>> {
    
   //初步汇总，注册了很多Feature类的东西
   public static final Feature<NoFeatureConfig> NO_OP = register("no_op", new NoOpFeature(NoFeatureConfig.CODEC));
   public static final Feature<BaseTreeFeatureConfig> TREE = register("tree", new TreeFeature(BaseTreeFeatureConfig.CODEC));
   public static final FlowersFeature<BlockClusterFeatureConfig> FLOWER = register("flower", new DefaultFlowersFeature(BlockClusterFeatureConfig.CODEC));
    //...将近五十行都是这些东西
    
    //以下是Feature作为祖宗类的成员方法，其中抽象方法place最重要
    private static <C extends IFeatureConfig, F extends Feature<C>> F register(String p_214468_0_, F p_214468_1_) {
      return Registry.register(Registry.FEATURE, p_214468_0_, p_214468_1_);
   }

   public Feature(Codec<FC> p_i231953_1_) {
      this.configuredCodec = p_i231953_1_.fieldOf("config").xmap((p_236296_1_) -> {
         return new ConfiguredFeature<>(this, p_236296_1_);
      }, (p_236295_0_) -> {
         return p_236295_0_.config;
      }).codec();
   }

   public Codec<ConfiguredFeature<FC, Feature<FC>>> configuredCodec() {
      return this.configuredCodec;
   }

   public ConfiguredFeature<FC, ?> configured(FC p_225566_1_) {
      return new ConfiguredFeature<>(this, p_225566_1_);
   }

   protected void setBlock(IWorldWriter p_230367_1_, BlockPos p_230367_2_, BlockState p_230367_3_) {
      p_230367_1_.setBlock(p_230367_2_, p_230367_3_, 3);
   }

   //这个非常重要
   public abstract boolean place(ISeedReader p_241855_1_, ChunkGenerator p_241855_2_, Random p_241855_3_, BlockPos p_241855_4_, FC p_241855_5_);

   protected static boolean isStone(Block p_227249_0_) {
      return net.minecraftforge.common.Tags.Blocks.STONE.contains(p_227249_0_);
   }

   public static boolean isDirt(Block p_227250_0_) {
      return net.minecraftforge.common.Tags.Blocks.DIRT.contains(p_227250_0_);
   }

   public static boolean isGrassOrDirt(IWorldGenerationBaseReader p_236293_0_, BlockPos p_236293_1_) {
      return p_236293_0_.isStateAtPosition(p_236293_1_, (p_236294_0_) -> {
         return isDirt(p_236294_0_.getBlock());
      });
   }

   public static boolean isAir(IWorldGenerationBaseReader p_236297_0_, BlockPos p_236297_1_) {
      return p_236297_0_.isStateAtPosition(p_236297_1_, AbstractBlock.AbstractBlockState::isAir);
   }
}
```

```java
//Features.java

public class Features {
    
   public static final ConfiguredFeature<?, ?> END_SPIKE = register("end_spike", Feature.END_SPIKE.configured(new EndSpikeFeatureConfig(false, ImmutableList.of(), (BlockPos)null)));
   public static final ConfiguredFeature<?, ?> END_GATEWAY = register("end_gateway", Feature.END_GATEWAY.configured(EndGatewayConfig.knownExit(ServerWorld.END_SPAWN_POINT, true)).decorated(Placement.END_GATEWAY.configured(IPlacementConfig.NONE)));
   public static final ConfiguredFeature<?, ?> END_GATEWAY_DELAYED = register("end_gateway_delayed", Feature.END_GATEWAY.configured(EndGatewayConfig.delayedExitSearch()));
   public static final ConfiguredFeature<?, ?> LAKE_WATER = register("lake_water", Feature.LAKE.configured(new BlockStateFeatureConfig(Features.States.WATER)).decorated(Placement.WATER_LAKE.configured(new ChanceConfig(4))));
   
   //将近200行都是这些东西
    
    
    //用于注册的方法
    private static <FC extends IFeatureConfig> ConfiguredFeature<FC, ?> register(String p_243968_0_, ConfiguredFeature<FC, ?> p_243968_1_) {
      return Registry.register(WorldGenRegistries.CONFIGURED_FEATURE, p_243968_0_, p_243968_1_);
   }
    
    
    //存放config的内部类
    public static final class Configs {
      //...
    }
    
    //存放placement的内部类
    public static final class Placements {
        //...
    }
    
    //存放BlockState的内部类
    public static final class States {
        //...
    }
}
```

代码很复杂？没有关系，只要知道，一个特性必须在Feature类里注册一次，再经config之手在Features里注册一次才能成功，就可以了。

原版数据包中，在"Features"的十个括号里填写的就是各种ConfiguredFeature的注册名，比如：

向上稍微翻一翻，可以看到Features.java里第四个（实际上是我特地把它列在前面了）ConfiguredFeature注册名是"lake_water"，加上默认命名空间正好就是"minecraft:lake_water"，出现在"features"的第二个中括号里。你也可以试着翻翻Features.java，和以下这些代码对比着看，会发现这些注册名全部都能在Features.java中找到，无一例外。

```json
//worldgen/biome/plains.json节选

"features": [
    [],
    [
      "minecraft:lake_water",
      "minecraft:lake_lava"
    ],
    [],
    [
      "minecraft:monster_room"
    ],
    [],
    [],
    [
      "minecraft:ore_dirt",
      "minecraft:ore_gravel",
      "minecraft:ore_granite",
      "minecraft:ore_diorite",
      "minecraft:ore_andesite",
      "minecraft:ore_coal",
      "minecraft:ore_iron",
      "minecraft:ore_gold",
      "minecraft:ore_redstone",
      "minecraft:ore_diamond",
      "minecraft:ore_lapis",
      "minecraft:disk_sand",
      "minecraft:disk_clay",
      "minecraft:disk_gravel"
    ],
    [],
    [
      "minecraft:patch_tall_grass_2",
      "minecraft:plain_vegetation",
      "minecraft:flower_plain_decorated",
      "minecraft:patch_grass_plain",
      "minecraft:brown_mushroom_normal",
      "minecraft:red_mushroom_normal",
      "minecraft:patch_sugar_cane",
      "minecraft:patch_pumpkin",
      "minecraft:spring_water",
      "minecraft:spring_lava"
    ],
    [
      "minecraft:freeze_top_layer"
    ]
  ]
```



#### 补：Structure和StructureFeatures

这两个东西特别容易和Feature和Features混在一起，我在此把它们的关系彻底理清。

之所以我们有理解上的混乱，我认为有两个因素：

1. Mojang程序猿命名时~~头脑一热~~不太小心，没有遵循约定俗成的命名习惯（单数祖宗或初次汇总，复数二次汇总），反而和别的类名搅合在一起；
2. 中文译名十分混乱，没有一个统一好理解的称呼。

实际上，Structure如大家所想，是祖宗类兼初次汇总类，代码就不贴了，总之里面注册了很多Structure类型的东西。

*”但是，StructureFeatures到底是何方神圣啊？它到底是Structure还是Feature呢？“*

答案揭晓，它就是一个二次汇总类，本应该叫Structures的！

奇怪的是，Mojang并没有一个源文件的名字叫Structures，所以为什么不取这个名字呢？我认为一个很可能的原因是，Structure在二次汇总时需要通过config一通操作，而这些config，与Feature二次汇总时的那些config是一种东西，因为这些config都实现**IFeatureConfig**接口。

Structure经过config操作后，生成了新的数据类型：StructureFeature。

StructureFeatures里就注册了很多StructureFeature。

上面这些解释很可能会把大家给绕进去，所以我画了一张表格。

![image-20220513200328181](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220513200328181.png)

我不清楚这些类名到1.18有没有变化，总之我强烈建议Mojang把StructureFeatures改成Structures，StructureFeature改成ConfiguredStructure（原来的命名会逼疯强迫症。。）